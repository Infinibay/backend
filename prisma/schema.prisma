generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          String                     @id @default(uuid())
  email                       String                     @unique
  password                    String
  deleted                     Boolean
  token                       String                     @default("null")
  firstName                   String
  lastName                    String
  createdAt                   DateTime                   @default(now())
  role                        UserRole                   @default(USER)
  updatedAt                   DateTime                   @updatedAt
  VM                          Machine[]
  maintenanceHistory          MaintenanceHistory[]
  maintenanceTasks            MaintenanceTask[]
  scripts                     Script[]
  scriptExecutions            ScriptExecution[]
  departmentScriptAssignments DepartmentScript[]
  scriptAuditLogs             ScriptAuditLog[]
  approvedScripts             Script[]                   @relation("ScriptApprovals")
}

model Node {
  id          String   @id @default(uuid())
  name        String
  currentRaid String
  nextRaid    String?
  cpuFlags    Json
  ram         Int
  cores       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  disks       Disk[]
}

model Disk {
  id        String   @id @default(uuid())
  path      String
  nodeId    String
  status    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  node      Node     @relation(fields: [nodeId], references: [id])
}

model ISO {
  id           String    @id @default(uuid())
  filename     String    @unique
  os           String
  version      String?
  size         BigInt
  uploadedAt   DateTime  @default(now())
  lastVerified DateTime?
  isAvailable  Boolean   @default(true)
  checksum     String?
  downloadUrl  String?
  path         String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model Machine {
  id                        String                     @id @default(uuid())
  name                      String
  internalName              String
  status                    String
  userId                    String?
  templateId                String?
  os                        String
  cpuCores                  Int                        @default(0)
  ramGB                     Int                        @default(0)
  diskSizeGB                Int                        @default(0)
  gpuPciAddress             String?
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  departmentId              String?
  version                   Int                        @default(1)
  localIP                   String?
  publicIP                  String?
  firewallRuleSetId         String?                    @unique
  applicationUsage          ApplicationUsage[]
  department                Department?                @relation(fields: [departmentId], references: [id])
  firewallRuleSet           FirewallRuleSet?           @relation(fields: [firewallRuleSetId], references: [id], onDelete: SetNull)
  template                  MachineTemplate?           @relation(fields: [templateId], references: [id])
  user                      User?                      @relation(fields: [userId], references: [id])
  applications              MachineApplication[]
  configuration             MachineConfiguration?
  maintenanceHistory        MaintenanceHistory[]
  maintenanceTasks          MaintenanceTask[]
  pendingCommands           PendingCommand[]
  portUsage                 PortUsage[]
  blockedConnections        BlockedConnection[]
  processSnapshots          ProcessSnapshot[]
  systemEvents              SystemEvent[]
  systemMetrics             SystemMetrics[]
  healthAlerts              VMHealthAlert[]
  healthCheckQueue          VMHealthCheckQueue[]
  healthConfig              VMHealthConfig?
  healthSnapshots           VMHealthSnapshot[]
  recommendations           VMRecommendation[]
  windowsServices           WindowsService[]
  scriptExecutions          ScriptExecution[]
}

model MachineConfiguration {
  id              String   @id @default(uuid())
  xml             Json?
  graphicProtocol String?
  graphicPort     Int?
  graphicPassword String?
  graphicHost     String?
  assignedGpuBus  String?
  machineId       String   @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  machine         Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  // Infinization QEMU process management fields (nullable for backward compatibility)
  qmpSocketPath   String?  // Unix socket path for QMP communication
  qemuPid         Int?     // QEMU process PID for health monitoring
  tapDeviceName   String?  // TAP network device name for cleanup

  // ============================================================================
  // QEMU CONFIGURATION FIELDS
  // ============================================================================
  // These fields configure QEMU VM parameters. All fields are nullable for
  // backward compatibility with existing VMs.
  //
  // NULL VALUE HANDLING (for consuming code like VMLifecycle, QemuCommandBuilder):
  // - A null value means "use default behavior" as specified in @default()
  // - Non-null values override the default behavior
  // - When reading these fields, apply the intended default if null:
  //     const bridge = config.bridge ?? 'virbr0';
  //     const machineType = config.machineType ?? 'q35';
  //
  // Fields with @default() get that value on INSERT, but existing rows will
  // have NULL until explicitly updated. Always handle null in consuming code.
  // ============================================================================

  // Network configuration (HIGH PRIORITY)
  // Network bridge device name (e.g., virbr0, br0) - used by VMLifecycle to create TAP devices
  bridge          String?  @default("virbr0")
  // NIC model for network device (virtio-net-pci provides best performance)
  networkModel    String?  @default("virtio-net-pci")
  // Multi-queue networking support - number of queues for parallel packet processing
  networkQueues   Int?     @default(1)

  // Machine configuration (HIGH PRIORITY)
  // QEMU machine type (q35 is modern chipset with PCIe support, i440fx for legacy)
  machineType     String?  @default("q35")
  // CPU model for guest (host provides best performance, or specific model for migration compatibility)
  cpuModel        String?  @default("host")

  // Storage configuration (HIGH PRIORITY)
  // Disk bus type (virtio for performance, scsi/sata for compatibility)
  diskBus         String?  @default("virtio")
  // Disk cache mode: writeback (performance), writethrough (safety), none (direct I/O)
  diskCacheMode   String?  @default("writeback")
  // Enable I/O threading for disk operations - offloads I/O to dedicated threads
  ioThreads       Boolean? @default(false)
  // Multi-disk support - stores array of disk paths as JSON
  // Format: ["path/to/disk1.qcow2", "path/to/disk2.qcow2"]
  // NULL or empty array means use legacy single-disk path computation
  diskPaths       Json?

  // GPU configuration (ADDITIONAL)
  // Path to GPU ROM file for passthrough (needed for some GPUs)
  gpuRomFile      String?
  // PCI address for GPU audio device passthrough
  gpuAudioBus     String?

  // Performance features (MEDIUM PRIORITY)
  // Enable dynamic memory management via balloon device
  memoryBalloon   Boolean? @default(false)
  // Use hugepages for better memory performance (requires host configuration)
  hugepages       Boolean? @default(false)

  // Advanced configuration (LOW PRIORITY)
  // NUMA topology configuration for multi-socket optimization (format: {"nodes": [...]})
  numaConfig      Json?
  // CPU affinity configuration (format: {"cores": [0, 1, 2]}) - uses cgroups v2
  cpuPinning      Json?

  // NUMA-aware CPU pinning via numactl process wrapper
  // When enabled, QEMU is launched with numactl to pin CPUs and memory to NUMA nodes
  enableNumaCtlPinning  Boolean? @default(false)
  // Strategy for automatic CPU pinning: 'basic' (sequential) or 'hybrid' (randomized)
  cpuPinningStrategy    String?  @default("basic")

  // UEFI configuration (LOW PRIORITY)
  // Path to OVMF firmware file for UEFI boot
  uefiFirmware    String?
  // Enable UEFI Secure Boot
  secureboot      Boolean? @default(false)

  // ============================================================================
  // QEMU DEVICE SOCKET PATHS
  // ============================================================================
  // These fields store socket paths for various QEMU devices and channels.
  // All fields are nullable for backward compatibility.

  // TPM 2.0 socket path for Trusted Platform Module emulation (Windows 11 requirement)
  tpmSocketPath           String?
  // QEMU Guest Agent socket for host-guest communication
  guestAgentSocketPath    String?
  // InfiniService custom channel socket for application management
  infiniServiceSocketPath String?

  // ============================================================================
  // ADDITIONAL VM CONFIGURATION
  // ============================================================================
  // VirtIO drivers ISO path for Windows VMs
  virtioDriversIso        String?
  // Enable Intel HDA audio device
  enableAudio             Boolean? @default(false)
  // Enable USB tablet for absolute mouse positioning
  enableUsbTablet         Boolean? @default(true)

  // ============================================================================
  // INSTALLATION STATE TRACKING
  // ============================================================================
  // true = VM has completed initial setup (infiniservice connected for first time)
  // false/null = VM still in building/installation phase
  setupComplete           Boolean? @default(false)
}

model MachineTemplate {
  id          String                   @id @default(uuid())
  name        String
  description String?
  cores       Int
  /// In GB
  ram         Int
  /// In GB
  storage     Int
  createdAt   DateTime                 @default(now())
  categoryId  String?
  updatedAt   DateTime                 @updatedAt
  machines    Machine[]
  category    MachineTemplateCategory? @relation(fields: [categoryId], references: [id])
}

model MachineTemplateCategory {
  id          String            @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  templates   MachineTemplate[]
}

model Application {
  id             String               @id @default(uuid())
  name           String
  description    String?
  version        String?
  url            String?
  icon           String?
  os             String[]
  installCommand Json
  parameters     Json
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  machines       MachineApplication[]
}

model MachineApplication {
  machineId     String
  applicationId String
  parameters    Json
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  application   Application @relation(fields: [applicationId], references: [id])
  machine       Machine     @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@id([machineId, applicationId])
}

model PendingCommand {
  id         String   @id @default(uuid())
  machineId  String
  command    String
  parameters Json
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  machine    Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId])
}

model Notification {
  id        String   @id @default(uuid())
  message   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Department {
  id                    String             @id @default(uuid())
  name                  String
  createdAt             DateTime           @default(now())
  internetSpeed         Int?
  ipSubnet              String?
  updatedAt             DateTime           @updatedAt
  firewallRuleSetId     String?            @unique
  firewallRuleSet       FirewallRuleSet?   @relation(fields: [firewallRuleSetId], references: [id], onDelete: SetNull)
  machines              Machine[]
  scriptAssignments     DepartmentScript[]

  // Network infrastructure fields
  bridgeName            String?            // Linux bridge name: "infinibr-{shortId}" (max 15 chars)
  gatewayIP             String?            // Gateway IP on bridge: "10.10.100.1"
  dhcpRangeStart        String?            // DHCP pool start: "10.10.100.10"
  dhcpRangeEnd          String?            // DHCP pool end: "10.10.100.254"
  dnsmasqPid            Int?               // PID of dnsmasq process for this bridge
  dnsServers            String[]           @default(["8.8.8.8", "8.8.4.4", "1.1.1.1"]) // DNS servers for DHCP clients
  ntpServers            String[]           @default(["216.239.35.0", "162.159.200.1"]) // NTP servers for DHCP clients (Google: 216.239.35.0, Cloudflare: 162.159.200.1)
  mtu                   Int?               @default(1500) // MTU for DHCP clients (default: 1500 for standard Ethernet)

  // Firewall policy configuration
  firewallPolicy        FirewallPolicy     @default(BLOCK_ALL)
  firewallDefaultConfig String?            @default("allow_outbound")
  firewallCustomRules   Json?

  @@index([bridgeName])
}

model SystemMetrics {
  id                String   @id @default(uuid())
  machineId         String
  cpuUsagePercent   Float
  cpuCoresUsage     Json
  cpuTemperature    Float?
  totalMemoryKB     BigInt
  usedMemoryKB      BigInt
  availableMemoryKB BigInt
  swapTotalKB       BigInt?
  swapUsedKB        BigInt?
  diskUsageStats    Json
  diskIOStats       Json
  networkStats      Json
  uptime            BigInt
  loadAverage       Json?
  timestamp         DateTime @default(now())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  machine           Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, timestamp])
}

model ProcessSnapshot {
  id              String    @id @default(uuid())
  machineId       String
  processId       Int
  parentPid       Int?
  name            String
  executablePath  String?
  commandLine     String?
  cpuUsagePercent Float
  memoryUsageKB   BigInt
  diskReadBytes   BigInt?
  diskWriteBytes  BigInt?
  status          String
  startTime       DateTime?
  timestamp       DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  machine         Machine   @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, timestamp])
  @@index([machineId, processId, timestamp])
}

model ApplicationUsage {
  id                String    @id @default(uuid())
  machineId         String
  executablePath    String
  applicationName   String
  version           String?
  description       String?
  publisher         String?
  lastAccessTime    DateTime?
  lastModifiedTime  DateTime?
  accessCount       Int       @default(0)
  totalUsageMinutes Int       @default(0)
  iconData          Bytes?
  iconFormat        String?
  fileSize          BigInt?
  firstSeen         DateTime  @default(now())
  lastSeen          DateTime  @default(now())
  isActive          Boolean   @default(true)
  updatedAt         DateTime  @updatedAt
  machine           Machine   @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@unique([machineId, executablePath])
  @@index([machineId, lastAccessTime])
  @@index([machineId, isActive])
}

model PortUsage {
  id              String   @id @default(uuid())
  machineId       String
  port            Int
  protocol        String
  state           String
  processId       Int?
  processName     String?
  executablePath  String?
  isListening     Boolean  @default(false)
  connectionCount Int      @default(0)
  lastActivity    DateTime @default(now())
  timestamp       DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  machine         Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, port, protocol])
  @@index([machineId, timestamp])
  @@index([machineId, isListening])
}

model BlockedConnection {
  id          String   @id @default(uuid())
  machineId   String
  port        Int
  protocol    String
  processName String?
  processId   Int?
  attemptTime DateTime @default(now())
  blockReason String
  sourceIp    String?
  ruleId      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  machine     Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, attemptTime])
  @@index([machineId, port, protocol])
}

model WindowsService {
  id               String                @id @default(uuid())
  machineId        String
  serviceName      String
  displayName      String
  description      String?
  startType        String
  serviceType      String
  executablePath   String?
  dependencies     Json?
  currentState     String
  processId        Int?
  lastStateChange  DateTime?
  stateChangeCount Int                   @default(0)
  isDefaultService Boolean               @default(false)
  usageScore       Float?                @default(0)
  firstSeen        DateTime              @default(now())
  lastSeen         DateTime              @default(now())
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  stateHistory     ServiceStateHistory[]
  machine          Machine               @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@unique([machineId, serviceName])
  @@index([machineId, currentState])
  @@index([machineId, isDefaultService])
}

model ServiceStateHistory {
  id        String         @id @default(uuid())
  serviceId String
  fromState String?
  toState   String
  reason    String?
  timestamp DateTime       @default(now())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  service   WindowsService @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([serviceId, timestamp])
}

model ErrorLog {
  id        String   @id @default(uuid())
  message   String
  stack     String?
  code      String
  severity  String
  context   Json?
  timestamp DateTime @default(now())
  resolved  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([timestamp])
  @@index([severity, timestamp])
  @@index([code, timestamp])
}

model PerformanceMetric {
  id        String   @id @default(uuid())
  name      String
  value     Float
  tags      Json?
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name, timestamp])
  @@index([timestamp])
}

model PerformanceAggregate {
  id        String   @id @default(uuid())
  name      String
  period    String
  count     Int
  sum       Float
  min       Float
  max       Float
  avg       Float
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name, period, timestamp])
  @@index([timestamp])
}

model HealthCheck {
  id           String   @id @default(uuid())
  service      String
  status       String
  message      String?
  details      Json?
  responseTime Int?
  timestamp    DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([service, timestamp])
  @@index([status, timestamp])
  @@index([timestamp])
}

model BackgroundTaskLog {
  id         String    @id @default(uuid())
  taskId     String    @unique
  taskName   String
  status     String
  startTime  DateTime
  endTime    DateTime?
  retryCount Int       @default(0)
  error      String?
  result     Json?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([status, createdAt])
  @@index([taskName, createdAt])
  @@index([createdAt])
}

model VMHealthAlert {
  id          String    @id @default(uuid())
  machineId   String
  type        String
  severity    String
  title       String
  description String
  resolved    Boolean   @default(false)
  resolvedAt  DateTime?
  metadata    Json?
  remediation Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  machine     Machine   @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, resolved])
  @@index([machineId, severity])
  @@index([createdAt])
}

model VMHealthConfig {
  id                   String   @id @default(uuid())
  machineId            String   @unique
  checkIntervalMinutes Int      @default(5)
  metricsRetentionDays Int      @default(7)
  thresholds           Json
  enabledModules       String[]
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  machine              Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)
}

model KnownService {
  id          String   @id @default(uuid())
  name        String   @unique
  displayName String
  description String
  category    String
  ports       Json
  executable  String?
  os          String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model SystemEvent {
  id          String   @id @default(uuid())
  machineId   String
  eventType   String
  severity    String
  title       String
  description String
  metadata    Json?
  timestamp   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  machine     Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, timestamp])
  @@index([machineId, eventType])
}

model VMHealthSnapshot {
  id                   String                @id @default(uuid())
  machineId            String
  snapshotDate         DateTime              @default(now())
  overallStatus        String
  diskSpaceInfo        Json?
  resourceOptInfo      Json?
  windowsUpdateInfo    Json?
  defenderStatus       Json?
  applicationInventory Json?
  customCheckResults   Json?
  osType               String?
  checksCompleted      Int                   @default(0)
  checksFailed         Int                   @default(0)
  executionTimeMs      Int?
  errorSummary         String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  machine              Machine               @relation(fields: [machineId], references: [id], onDelete: Cascade)
  recommendations      VMRecommendation[]

  @@index([machineId, snapshotDate])
  @@index([snapshotDate])
  @@index([machineId, overallStatus])
}

model VMHealthCheckQueue {
  id              String          @id @default(uuid())
  machineId       String
  checkType       HealthCheckType
  priority        TaskPriority    @default(MEDIUM)
  status          TaskStatus      @default(PENDING)
  payload         Json?
  attempts        Int             @default(0)
  maxAttempts     Int             @default(3)
  scheduledFor    DateTime        @default(now())
  executedAt      DateTime?
  completedAt     DateTime?
  error           String?
  result          Json?
  executionTimeMs Int?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  machine         Machine         @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, status])
  @@index([status, priority, scheduledFor])
  @@index([scheduledFor, status])
  @@index([machineId, checkType, status])
}

model MaintenanceTask {
  id              String               @id @default(uuid())
  machineId       String
  taskType        MaintenanceTaskType
  name            String
  description     String?
  isEnabled       Boolean              @default(true)
  isRecurring     Boolean              @default(false)
  cronSchedule    String?
  runAt           DateTime?
  nextRunAt       DateTime?
  lastRunAt       DateTime?
  parameters      Json?
  createdByUserId String
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  executionStatus String               @default("IDLE")
  history         MaintenanceHistory[]
  createdBy       User                 @relation(fields: [createdByUserId], references: [id])
  machine         Machine              @relation(fields: [machineId], references: [id], onDelete: Cascade)

  @@index([machineId, isEnabled])
  @@index([machineId, taskType])
  @@index([nextRunAt, isEnabled])
  @@index([taskType, isEnabled])
}

model MaintenanceHistory {
  id               String              @id @default(uuid())
  taskId           String?
  machineId        String
  taskType         MaintenanceTaskType
  status           MaintenanceStatus
  duration         Int?
  result           Json?
  error            String?
  triggeredBy      MaintenanceTrigger
  executedByUserId String?
  executedAt       DateTime            @default(now())
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  executedBy       User?               @relation(fields: [executedByUserId], references: [id])
  machine          Machine             @relation(fields: [machineId], references: [id], onDelete: Cascade)
  task             MaintenanceTask?    @relation(fields: [taskId], references: [id])

  @@index([machineId, executedAt])
  @@index([machineId, status])
  @@index([taskType, status])
  @@index([executedAt])
}

model VMRecommendation {
  id         String             @id @default(uuid())
  machineId  String
  snapshotId String?
  type       RecommendationType
  text       String
  actionText String
  data       Json?
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  machine    Machine            @relation(fields: [machineId], references: [id], onDelete: Cascade)
  snapshot   VMHealthSnapshot?  @relation(fields: [snapshotId], references: [id])

  // Package system: tracks which package/checker generated this recommendation
  packageId   String?
  checkerName String?

  // Dismissal and snooze tracking
  dismissedAt  DateTime? // When the recommendation was dismissed
  snoozedUntil DateTime? // When the snooze period ends (null = not snoozed)

  @@index([machineId, createdAt])
  @@index([machineId, snapshotId])
  @@index([packageId])
  @@index([dismissedAt])
  @@index([snoozedUntil])
}

model AppSettings {
  id            String   @id @default(uuid())
  theme         String   @default("system")
  wallpaper     String   @default("wallpaper1.jpg")
  logoUrl       String?
  interfaceSize String   @default("xl")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([id])
}

model Script {
  id                        String                     @id @default(uuid())
  name                      String
  description               String?
  fileName                  String                     @unique
  category                  String?
  tags                      String[]
  os                        OS[]
  shell                     ShellType
  // Approval workflow fields (optional/future enhancement)
  // Default status is APPROVED for backward compatibility
  // To enable: check status === APPROVED before execution in ScriptExecutor
  // Add mutations to approve/reject and set approvedById/approvedAt
  status                    ScriptStatus               @default(APPROVED)
  approvedById              String?
  approvedBy                User?                      @relation("ScriptApprovals", fields: [approvedById], references: [id])
  approvedAt                DateTime?
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  createdById               String?
  createdBy                 User?                      @relation(fields: [createdById], references: [id])
  executions                ScriptExecution[]
  departmentAssignments     DepartmentScript[]
  auditLogs                 ScriptAuditLog[]

  @@index([fileName])
  @@index([category])
  @@index([createdById])
}

model DepartmentScript {
  id           String     @id @default(uuid())
  departmentId String
  scriptId     String
  assignedAt   DateTime   @default(now())
  assignedById String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  script       Script     @relation(fields: [scriptId], references: [id], onDelete: Cascade)
  assignedBy   User       @relation(fields: [assignedById], references: [id])

  @@unique([departmentId, scriptId])
  @@index([departmentId])
  @@index([scriptId])
}

model ScriptExecution {
  id                       String                    @id @default(uuid())
  scriptId                 String
  machineId                String
  executionType            ExecutionType
  triggeredById            String?
  inputValues              Json
  status                   ExecutionStatus
  startedAt                DateTime?
  completedAt              DateTime?
  exitCode                 Int?
  stdout                   String?                   @db.Text
  stderr                   String?                   @db.Text
  error                    String?                   @db.Text
  executedAs               String?
  // Scheduling fields for immediate, scheduled, and repeating executions
  scheduledFor             DateTime?                 // When script should execute (NULL or past = immediate)
  repeatIntervalMinutes    Int?                      // Interval in minutes for repeating scripts (NULL = one-time)
  lastExecutedAt           DateTime?                 // Timestamp of last execution attempt
  executionCount           Int                       @default(0)  // Number of times executed
  maxExecutions            Int?                      // Maximum executions for repeating scripts (NULL = unlimited)
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  script                   Script                    @relation(fields: [scriptId], references: [id], onDelete: Cascade)
  machine                  Machine                   @relation(fields: [machineId], references: [id], onDelete: Cascade)
  triggeredBy              User?                     @relation(fields: [triggeredById], references: [id])

  @@index([machineId, createdAt])
  @@index([scriptId, createdAt])
  @@index([status])
  @@index([machineId, status])
  @@index([machineId, status, scheduledFor])
  @@index([status, scheduledFor])
}

model ScriptAuditLog {
  id         String            @id @default(uuid())
  scriptId   String
  userId     String?
  action     ScriptAuditAction
  details    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime          @default(now())
  script     Script            @relation(fields: [scriptId], references: [id], onDelete: Cascade)
  user       User?             @relation(fields: [userId], references: [id])

  @@index([scriptId, createdAt])
  @@index([userId, createdAt])
  @@index([action, createdAt])
}

// ============================================================================
// PACKAGE SYSTEM MODELS
// ============================================================================

// Extensible packages/plugins that provide additional functionality
model Package {
  id          String   @id @default(uuid())
  name        String   @unique // "ai-diagnostics"
  version     String
  displayName String
  description String?
  author      String
  license     String // "open-source" | "commercial"

  isBuiltin Boolean @default(false)
  isEnabled Boolean @default(true)

  capabilities Json // { network: [...], storage: true }
  settings     Json @default("{}") // Values configured by admin
  manifestHash String // SHA256 of manifest to detect changes

  installedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  checkers       PackageChecker[]
  packageLicense PackageLicense?

  @@index([isEnabled])
  @@index([license])
}

// License validation for commercial packages
model PackageLicense {
  id        String  @id @default(uuid())
  packageId String  @unique
  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)

  // License identification
  licenseKey  String @unique
  licenseType String // "trial" | "production" | "development"

  // Validation constraints
  issuedAt    DateTime
  expiresAt   DateTime?
  maxMachines Int? // null = unlimited

  // State tracking
  isValid          Boolean  @default(true)
  validationStatus String   @default("valid") // "valid" | "expired" | "invalid" | "revoked" | "grace_period"
  lastValidatedAt  DateTime?
  gracePeriodEnds  DateTime? // Allow operation if license server unreachable

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isValid])
  @@index([licenseType])
  @@index([validationStatus])
}

// Individual checkers within a package that can generate recommendations
model PackageChecker {
  id        String  @id @default(uuid())
  packageId String
  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)

  name      String // "predictive-disk-failure"
  type      String // RecommendationType that it generates
  dataNeeds String[] // ["diskMetrics", "historicalMetrics"]
  isEnabled Boolean @default(true)

  @@unique([packageId, name])
  @@index([packageId])
  @@index([isEnabled])
}

model FirewallRuleSet {
  id            String        @id @default(uuid())
  name          String
  internalName  String        @unique
  entityType    RuleSetType
  entityId      String
  priority      Int           @default(500)
  isActive      Boolean       @default(true)
  libvirtUuid   String?       @unique
  xmlContent    String?
  lastSyncedAt  DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  department    Department?
  machine       Machine?
  rules         FirewallRule[]

  @@unique([entityType, entityId])
  @@index([isActive])
}

model FirewallRule {
  id                String          @id @default(uuid())
  ruleSetId         String
  name              String
  description       String?
  action            RuleAction      @default(ACCEPT)
  direction         RuleDirection   @default(INOUT)
  priority          Int             @default(500)
  protocol          String          @default("all")
  srcPortStart      Int?
  srcPortEnd        Int?
  dstPortStart      Int?
  dstPortEnd        Int?
  srcIpAddr         String?
  srcIpMask         String?
  dstIpAddr         String?
  dstIpMask         String?
  connectionState   Json?
  overridesDept     Boolean         @default(false)
  isSystemGenerated Boolean         @default(false) // True for rules auto-generated by firewall policy presets
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  ruleSet           FirewallRuleSet @relation(fields: [ruleSetId], references: [id], onDelete: Cascade)

  @@index([ruleSetId, priority])
}

enum RuleSetType {
  DEPARTMENT
  VM
}

enum RuleAction {
  ACCEPT
  DROP
  REJECT
}

enum RuleDirection {
  IN
  OUT
  INOUT
}

enum HealthCheckType {
  OVERALL_STATUS
  DISK_SPACE
  RESOURCE_OPTIMIZATION
  WINDOWS_UPDATES
  WINDOWS_DEFENDER
  APPLICATION_INVENTORY
  APPLICATION_UPDATES
  SECURITY_CHECK
  PERFORMANCE_CHECK
  SYSTEM_HEALTH
  CUSTOM_CHECK
}

enum TaskStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  RETRY_SCHEDULED
}

enum TaskPriority {
  URGENT
  HIGH
  MEDIUM
  LOW
}

enum MaintenanceTaskType {
  DISK_CLEANUP
  DEFRAG
  WINDOWS_UPDATES
  DEFENDER_SCAN
  SYSTEM_FILE_CHECK
  DISK_CHECK
  REGISTRY_CLEANUP
  CUSTOM_SCRIPT
}

enum MaintenanceStatus {
  SUCCESS
  FAILED
  CANCELLED
  TIMEOUT
  RUNNING
}

enum MaintenanceTrigger {
  SCHEDULED
  MANUAL
}

enum RecommendationType {
  DISK_SPACE_LOW
  HIGH_CPU_APP
  HIGH_RAM_APP
  PORT_BLOCKED
  OVER_PROVISIONED
  UNDER_PROVISIONED
  OS_UPDATE_AVAILABLE
  APP_UPDATE_AVAILABLE
  DEFENDER_DISABLED
  DEFENDER_THREAT
  OTHER
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum OS {
  WINDOWS
  LINUX
}

enum ShellType {
  POWERSHELL
  CMD
  BASH
  SH
}

enum ExecutionType {
  FIRST_BOOT
  ON_DEMAND
  SCHEDULED
}

enum ExecutionStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  TIMEOUT
  CANCELLED
}

enum ScriptStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
}

enum ScriptAuditAction {
  CREATED
  EDITED
  APPROVED
  REJECTED
  EXECUTED
  SCHEDULED
  DELETED
}

enum FirewallPolicy {
  ALLOW_ALL // Lista blanca - Permitir todo por defecto
  BLOCK_ALL // Lista negra - Bloquear todo por defecto
}
