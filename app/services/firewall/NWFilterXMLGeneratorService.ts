import { v4 as uuidv4 } from 'uuid'
import xml2js from 'xml2js'

import { FirewallRule, RuleSetType } from '@prisma/client'

import { FilterNameGenerator } from '@utils/firewall/FilterNameGenerator'

interface FilterConfig {
  name: string;
  rules: FirewallRule[];
}

/**
 * @deprecated Este servicio es parte de la arquitectura legacy basada en libvirt nwfilter XML.
 * La nueva arquitectura utiliza nftables que no requiere generación de XML.
 * Este servicio se mantiene solo para compatibilidad con código legacy y será eliminado en futuras versiones.
 *
 * Para nuevas implementaciones, las reglas se traducen directamente a sintaxis nftables
 * mediante FirewallRuleTranslator en infinivirt.
 *
 * Service responsible for generating libvirt nwfilter XML from firewall rules.
 * Implements the naming convention with 'ibay-' prefix for easy cleanup.
 */
export class NWFilterXMLGeneratorService {
  /**
   * @deprecated This method is part of the legacy libvirt XML-based firewall path.
   * For nftables-based implementations, chain names are generated by InfinivirtFirewallService.
   *
   * Generates a unique filter name with ibay- prefix.
   * Delegates to centralized FilterNameGenerator utility.
   *
   * Format: ibay-{type}-{hash}
   * Where hash is MD5 of entityId (truncated to 8 chars)
   */
  generateFilterName (entityType: RuleSetType, entityId: string): string {
    return FilterNameGenerator.generate(entityType, entityId)
  }

  /**
   * @deprecated This method is part of the legacy libvirt XML-based firewall path.
   * For nftables-based implementations, rules are translated directly via FirewallRuleTranslator
   * in infinivirt and applied through InfinivirtFirewallService.
   *
   * Generates complete nwfilter XML from a set of firewall rules
   * @param config - Filter configuration
   * @param parentFilterName - Optional parent filter to inherit from (for VM filters inheriting from dept)
   * @param existingUuid - Optional UUID to use instead of generating a new one (for updating existing filters)
   */
  async generateFilterXML (config: FilterConfig, parentFilterName?: string, existingUuid?: string): Promise<string> {
    // Sort rules by priority (lower number = higher priority)
    const sortedRules = [...config.rules].sort((a, b) => a.priority - b.priority)

    const filterObj: any = {
      filter: {
        $: {
          name: config.name,
          chain: 'root'
        },
        uuid: [existingUuid || uuidv4()]
      }
    }

    // Add parent filter reference if specified (for inheritance)
    if (parentFilterName) {
      filterObj.filter.filterref = [
        {
          $: {
            filter: parentFilterName
          }
        }
      ]
    }

    // Add rules if any
    if (sortedRules.length > 0) {
      filterObj.filter.rule = sortedRules.map(rule => this.generateRuleElement(rule))
    }

    const builder = new xml2js.Builder({
      xmldec: { version: '1.0', encoding: 'UTF-8' },
      renderOpts: { pretty: true, indent: '  ' }
    })

    return builder.buildObject(filterObj)
  }

  /**
   * Generates XML element for a single firewall rule
   */
  private generateRuleElement (rule: FirewallRule): any {
    const ruleElement: any = {
      $: {
        action: rule.action.toLowerCase(),
        direction: this.mapDirection(rule.direction),
        priority: rule.priority.toString()
      }
    }

    // Add connection state if specified
    if (rule.connectionState && typeof rule.connectionState === 'object') {
      const states = Object.keys(rule.connectionState)
        .filter(k => (rule.connectionState as any)[k])
        .map(s => s.toUpperCase())
        .join(',')

      if (states) {
        ruleElement.$.state = states
      }
    }

    // Handle protocol-specific attributes
    if (rule.protocol && rule.protocol !== 'all') {
      const protocolElement: any = {
        $: {}
      }

      // Add port specifications
      if (rule.srcPortStart !== null && rule.srcPortStart !== undefined) {
        protocolElement.$.srcportstart = rule.srcPortStart.toString()
      }
      if (rule.srcPortEnd !== null && rule.srcPortEnd !== undefined) {
        protocolElement.$.srcportend = rule.srcPortEnd.toString()
      }
      if (rule.dstPortStart !== null && rule.dstPortStart !== undefined) {
        protocolElement.$.dstportstart = rule.dstPortStart.toString()
      }
      if (rule.dstPortEnd !== null && rule.dstPortEnd !== undefined) {
        protocolElement.$.dstportend = rule.dstPortEnd.toString()
      }

      // Add IP address specifications
      if (rule.srcIpAddr) {
        protocolElement.$.srcipaddr = rule.srcIpAddr
      }
      if (rule.srcIpMask) {
        protocolElement.$.srcipmask = rule.srcIpMask
      }
      if (rule.dstIpAddr) {
        protocolElement.$.dstipaddr = rule.dstIpAddr
      }
      if (rule.dstIpMask) {
        protocolElement.$.dstipmask = rule.dstIpMask
      }

      ruleElement[rule.protocol] = [protocolElement]
    }

    return ruleElement
  }

  /**
   * Maps Prisma RuleDirection enum to libvirt nwfilter direction
   */
  private mapDirection (direction: string): string {
    switch (direction) {
    case 'IN':
      return 'in'
    case 'OUT':
      return 'out'
    case 'INOUT':
      return 'inout'
    default:
      return 'inout'
    }
  }

  /**
   * @deprecated This method is part of the legacy libvirt XML-based firewall path.
   * For nftables-based implementations, filter inheritance is handled natively by nftables chain structure
   * through InfinivirtFirewallService.
   *
   * Generates XML for a filter that references another filter
   * Used for hierarchical filter structures
   * @param existingUuid - Optional UUID to use instead of generating a new one (for updating existing filters)
   */
  async addFilterReference (parentFilterName: string, childFilterName: string, existingUuid?: string): Promise<string> {
    const filterObj = {
      filter: {
        $: {
          name: parentFilterName,
          chain: 'root'
        },
        uuid: [existingUuid || uuidv4()],
        filterref: [
          {
            $: {
              filter: childFilterName
            }
          }
        ]
      }
    }

    const builder = new xml2js.Builder({
      xmldec: { version: '1.0', encoding: 'UTF-8' },
      renderOpts: { pretty: true, indent: '  ' }
    })

    return builder.buildObject(filterObj)
  }
}
