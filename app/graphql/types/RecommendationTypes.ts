import { ObjectType, Field, ID, registerEnumType, InputType } from 'type-graphql'
import { GraphQLJSONObject } from 'graphql-type-json'
import { RecommendationType } from '@prisma/client'

// Register Prisma enum for GraphQL with detailed descriptions
registerEnumType(RecommendationType, {
  name: 'RecommendationType',
  description: 'Types of VM recommendations that can be generated by the system based on health checks and system analysis',
  valuesConfig: {
    DISK_SPACE_LOW: {
      description: 'Generated when disk space usage exceeds warning thresholds (typically 80-90%)'
    },
    OVER_PROVISIONED: {
      description: 'Generated when VM resources (CPU/RAM) are consistently underutilized over time'
    },
    UNDER_PROVISIONED: {
      description: 'Generated when VM resources are consistently over-utilized and affecting performance'
    },
    OS_UPDATE_AVAILABLE: {
      description: 'Generated when critical or security Windows updates are available'
    },
    APP_UPDATE_AVAILABLE: {
      description: 'Generated when application updates, especially security updates, are available'
    },
    DEFENDER_DISABLED: {
      description: 'Generated when Windows Defender antivirus or real-time protection is disabled'
    },
    DEFENDER_THREAT: {
      description: 'Generated when Windows Defender has detected active threats or quarantined items'
    },
    HIGH_CPU_APP: {
      description: 'Generated when specific applications are consuming excessive CPU resources'
    },
    HIGH_RAM_APP: {
      description: 'Generated when specific applications are consuming excessive memory resources'
    },
    PORT_BLOCKED: {
      description: 'Generated when firewall rules are blocking ports that applications are trying to use'
    },
    OTHER: {
      description: 'Generated for miscellaneous recommendations that do not fit other categories'
    }
  }
})

/**
 * VM recommendation object containing automated suggestions for VM optimization and maintenance
 */
@ObjectType({ description: 'Represents an automated recommendation for VM optimization, security, or maintenance' })
export class VMRecommendationType {
  @Field(() => ID, { description: 'Unique identifier for the recommendation' })
    id!: string

  @Field(() => ID, { description: 'ID of the VM this recommendation applies to' })
    machineId!: string

  @Field(() => ID, {
    nullable: true,
    description: 'ID of the health snapshot that generated this recommendation, if applicable'
  })
    snapshotId?: string | null

  @Field(() => RecommendationType, { description: 'Category of recommendation (storage, performance, security, etc.)' })
    type!: RecommendationType

  @Field(() => String, { description: 'Human-readable description of the issue or opportunity identified' })
    text!: string

  @Field(() => String, { description: 'Suggested action to address the recommendation' })
    actionText!: string

  @Field(() => GraphQLJSONObject, {
    nullable: true,
    description: 'Additional structured data specific to this recommendation type (metrics, thresholds, affected resources)'
  })
    data?: Record<string, any> | null

  @Field(() => Date, { description: 'Timestamp when this recommendation was generated' })
    createdAt!: Date
}

/**
 * Input type for filtering recommendations with various criteria
 */
@InputType({ description: 'Filters for querying VM recommendations with specific criteria' })
export class RecommendationFilterInput {
  @Field(() => [RecommendationType], {
    nullable: true,
    description: 'Filter by specific recommendation types (e.g., only security or storage recommendations)'
  })
    types?: RecommendationType[]

  @Field(() => Date, {
    nullable: true,
    description: 'Only return recommendations created after this date/time'
  })
    createdAfter?: Date

  @Field(() => Date, {
    nullable: true,
    description: 'Only return recommendations created before this date/time'
  })
    createdBefore?: Date

  @Field(() => Number, {
    nullable: true,
    description: 'Maximum number of recommendations to return (for pagination, defaults to 20, max 100)'
  })
    limit?: number
}

/**
 * Response type for recommendation operations
 */
@ObjectType()
export class RecommendationResponse {
  @Field(() => Boolean)
    success!: boolean

  @Field(() => String, { nullable: true })
    message?: string

  @Field(() => [VMRecommendationType])
    recommendations!: VMRecommendationType[]

  @Field(() => String, { nullable: true })
    error?: string
}

/**
 * Global recommendation with machine info for cross-VM views
 */
@ObjectType({ description: 'Recommendation with machine info for global views like notification dropdowns' })
export class GlobalRecommendationType {
  @Field(() => ID, { description: 'Unique identifier for the recommendation' })
    id!: string

  @Field(() => ID, { description: 'ID of the VM this recommendation applies to' })
    machineId!: string

  @Field(() => String, { description: 'Name of the VM for display purposes' })
    machineName!: string

  @Field(() => RecommendationType, { description: 'Category of recommendation' })
    type!: RecommendationType

  @Field(() => String, { description: 'Human-readable description of the issue' })
    text!: string

  @Field(() => String, { description: 'Suggested action to address the recommendation' })
    actionText!: string

  @Field(() => String, { description: 'Severity level: CRITICAL, HIGH, MEDIUM, LOW' })
    severity!: string

  @Field(() => GraphQLJSONObject, { nullable: true, description: 'Additional structured data' })
    data?: Record<string, any> | null

  @Field(() => Date, { description: 'Timestamp when this recommendation was generated' })
    createdAt!: Date
}

/**
 * Result type for dismiss operations
 */
@ObjectType({ description: 'Result of dismissing recommendation(s)' })
export class DismissRecommendationResult {
  @Field(() => Boolean, { description: 'Whether the operation succeeded' })
    success!: boolean

  @Field(() => Number, { nullable: true, description: 'Number of recommendations dismissed' })
    dismissedCount?: number

  @Field(() => String, { nullable: true, description: 'Error message if operation failed' })
    error?: string
}

/**
 * Result type for snooze operations
 */
@ObjectType({ description: 'Result of snoozing recommendation(s)' })
export class SnoozeRecommendationResult {
  @Field(() => Boolean, { description: 'Whether the operation succeeded' })
    success!: boolean

  @Field(() => Number, { nullable: true, description: 'Number of recommendations snoozed' })
    snoozedCount?: number

  @Field(() => Date, { nullable: true, description: 'When the snooze period ends' })
    snoozedUntil?: Date

  @Field(() => String, { nullable: true, description: 'Error message if operation failed' })
    error?: string
}

/**
 * Aggregated recommendation statistics for a VM
 */
@ObjectType()
export class RecommendationStats {
  @Field(() => ID)
    machineId!: string

  @Field(() => Number)
    totalRecommendations!: number

  @Field(() => Number)
    criticalRecommendations!: number

  @Field(() => Number)
    warningRecommendations!: number

  @Field(() => Number)
    infoRecommendations!: number

  @Field(() => Date, { nullable: true })
    lastGeneratedDate?: Date

  @Field(() => [RecommendationType])
    mostCommonTypes!: RecommendationType[]

  @Field(() => Number)
    resolvedCount!: number
}
